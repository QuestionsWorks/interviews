1、启动程序的作用
2、嵌入式程序开发的流程


建立开发环境，配置开发主机，建立引导装载程序bootloader，建立根文件系统，建立应用程序的flash磁盘分区，开发应用程序，烧写内核、根文件系统和应用程序，发布产品。


3、函数变成可重入函数
	1) 不要使用全局变量。因为别的代码很可能覆盖这些变量值。
     2) 在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”。
     3) 不能调用其它任何不可重入的函数。
     4) 谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。


4、声明和定义的区别
把建立空间的声明称之为"定义"，而把不需要建立存储空间称之为"声明"


5、指针函数和函数指针
1．指向函数的指针(函数指针)
来分析这样一个声明，void (*f) ( );虽然()的优先级高于*，但由于有括号存在，首先执行的是解引用，所以f是一个指针；接下来执行( )，表明f指向一个函数，这个函数不返回任何值。现在得出结论：f是一个指向不接受参数且不返回任何值的函数的指针，简称函数指针(pointer to function)。
对比一下int(*p) [100]，p是一个指向含有100个整型元素的数组的指针，它们有一个共同的特点：指针声明符(*)和标识符(f或p)都被限制在一个括号中，由于括号的优先级是最高的，所以我们从标识符开始由内向外分析，即可得到以上结果。
2．返回指针的函数(指针函数)
类比指针数组(还记得吗)，理解指针函数将会更加轻松。所谓指针函数，就是返回指针的函数，函数可以不返回任何值，也可以返回整型值，实型值，字符型值，当然也可以返回指针值。一个指针函数的声明：int *f(int i, int j); 回想一下指针数组的声明：char *cars[10];同样的把它写成好理解的形式(非业界惯例)int* f(int i, int j);这样一来已经十分明了了，由于( )的优先级高于*，因此f先与()结合，所以f是一个具有两个int型参数，返回一个指向int型指针的函数。
C语言的库函数中有很多都是指针函数，比如字符串处理函数，下面给出一些函数原型：
char *strcat( char *dest, const char *src );
char *strcpy( char *dest, const char *src );
char *strchr( const char *s, int c );
char *strstr( const char *src, const char*sub );
6、volatile用到的地方
1、中断服务程序中修改的供其它程序检测的变量需要加volatile；
2、多任务环境下各任务间共享的标志应该加volatile；
3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

7、大小端序
8、套接字的流程，在线词典的流程
9、6型循环链表的判定
有一个单向链表，如何判定这个链表当中是否包含有环路，以及如何定位环路在链表当中的开始点呢？

关于第一个问题，网络上可以搜索到，用两个指针来遍历这个单向链表，第一个指针p1，每次走一步；第二个指针p2，每次走两步；  当p2 指针追上 p1的时候，就表明链表当中有环路了。

关于这个解法最形象的比喻就是在操场当中跑步，速度快的会把速度慢的扣圈

可以证明，p2追赶上p1的时候，p1一定还没有走完一遍环路，p2也不会跨越p1多圈才追上

我们可以从p2和p1的位置差距来证明，p2一定会赶上p1但是不会跳过p1的

因为p2每次走2步，而p1走一步，所以他们之间的差距是一步一步的缩小，4，3，2，1，0 到0的时候就重合了

根据这个方式，可以证明，p2每次走三步以上，并不总能加快检测的速度，反而有可能判别不出有环

比如，在环的周长L是偶数的时候，初始p2和p1相差奇数的时候，p2每次走三步，就永远和p1不重合，因为他们之间的差距是：  5， 3 ， 1，  L－1， L－3


关于第二个问题，如何找到环路的入口，是这里要重点说明的内容：

解法如下： 当p2按照每次2步，p1每次一步的方式走，发现p2和p1重合，确定了单向链表有环路了

接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当p1和p2再次相遇的时候，就是环路的入口了。

这点可以证明的：

在p2和p1第一次相遇的时候，假定p1走了n步骤，环路的入口是在p步的时候经过的，那么有

p1走的路径： p+c ＝ n；         c为p1和p2相交点，距离环路入口的距离

p2走的路径： p+c+k*L = 2*n；   L为环路的周长，k是整数
可以推断出 L = P+C;

显然，如果从p+c点开始，p1再走n步骤的话，还可以回到p+c这个点

同时p2从头开始走的话，经过n不，也会达到p+c这点

显然在这个步骤当中p1和p2只有前p步骤走的路径不同，所以当p1和p2再次重合的时候，必然是在链表的环路入口点上

10、嵌入式中断描述
11、传参有哪几种方式，寄存器和堆栈存储变量的优缺点